#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>

void swap(int a, int b) {
	printf("a의 주소:%d\n", &a);
	printf("b의 주소:%d\n\n", &b);
	printf("함수 실행 중 a:%d,b:%d\n", a, b);
	int tmp = a;
	a = b;
	b = tmp;
	printf("함수 실행 중 a:%d,b:%d\n", a, b);

	/*함수의 매개변수는
	함수를 호출할때 넣어줬던 값을
	"복사"해서 사용하기 때문에
	함수를 호출할때 넣어준 변수와는
	값이 같을 뿐, 서로 아무런 상관이 없는 데이터이다.
	때문에 주소값도 서로 다르고
	함수 내에서 복사된 변수를 아무리 바꾼다 할지라도
	원본데이터인 함수 밖의 변수에는 
	아무런 영향도 끼치지 못한다.*/

	




}

void swap_pointer(int* a, int* b) {
	printf("a에 저장된 주소:%d\n", a);
	printf("b에 저장된 주소:%d\n", b);
	int tmp = *a;
	*a = *b;
	*b = tmp;
}

void add_pointer(int* a, int* b, int* c) {
	*c = *a + *b;
	printf("함수 적용 중 x,y,z 주소값 :%d, %d, %d\n", a, b, c);
	printf("함수 적용 중 x,y,z 값 :%d, %d, %d\n\n", *a, *b, *c);
}


int main() {
	/*
		포인터 
		데이터가 저장된 메모리의 위치값(주소값)을
		저장하는 변수
	*/

	int i = 50;

	int* p_i = &i;
	//변수 생성시에 자료형과 변수명 사이에
	//*을 붙이면 해당 변수는 주소값을 저장하는 변수가 된다.
	//여기서 *은 곱하기의 의미가 아닌 
	//포인터 변수를 만들겠다는 의미가 된다.

	printf("i:%d\n", i);
	printf("&i:%d\n", &i);
	printf("p_i:%d\n", p_i);
	/*생성한 데이터가 저장되는 주소값(p_i,&i)은
	실행 할때마다 현재 비어있는 메모리 위치 중에서
	프로그램이 자동적으로 선택하기 때문에
	실행할때마다 그 값이 바뀌고
	사용자가 임의의 주소값에 데이터를 넣을 순 없다.*/

	/*일반 변수 앞에 &기호를 붙이면
	해당변수가 저장된 주소값을 나타낸다.*/

	//======================================================
	


	/*포인터의 역참조
	포인터는 데이터가 저장된 주소값을 저장하는 변수이기에
	주소값을 알고 있다면 해당 주소값의 위치로 직접 찾아가서
	어떤 데이터가 저장되어 있는지 확인할 수 있다.
	때문에 포인터를 통해 해당 주소에 저장된 값을
	실제로 가져와서 사용하는 것이 가능하다.*/
	printf("*p_i:%d\n", *p_i);

	/*포인터의 역참조는 이미 생성된 포인터 변수 앞에
	'*'을 붙이면 사용할 수 있다.*/

	*p_i = 100;
	printf("i:%d\n", i);
	
	/*포인터의 역참조를 이용하면
	해당 주소값에 저장된 데이터를 사용할 수 있을 뿐 아니라
	저장된 데이터를 직접 바꿀 수도 있다.
	포인터 p_i는 변수 i의 주소이기 때문에
	p_i의 역참조값을 바꾸면
	i의 값 역시 바뀐다.*/

	/*포인터 변수값을 scanf로 대입할 수 있지만
	정상적인 주소가 아닐 가능성이 매우 높기 때문에
	사실상 사용하지 않는다.*/

	/*포인터 변수에 정수값을 대입하는 것도 가능은 하지만
	위와 같은이유로 해당주소가 정상적인 주소가
	아닐 가능성이 매우 높기 때문에
	사용하려 하면 에러가 발생한다.*/

	printf("10 + *p_i:%d\n", 10 + *p_i);

	/*포인터의 역참조는 해당 주소값에 저장된 데이터만 가져오기에
	역참조를 통해 가져온 데이터로 연산, 대입 등이 가능하다.*/

	/*	1) i; ->저장된 변수
		2) p_i; ->변수가 저장된 주소값
		3) &i;	->변수가 저장된 주소값
		4)* p_i;->저장된 변수
	*/

	/*
	int형 정수를 만들어서 데이터를 입력하고
	int형 포인터 변수를 생성해서
	int형 변수의 주소를 저장하고
	포인터를 이용해서 변수의 값을 바꾸고

	변수, 포인터변수, 변수의 주소,포인터변수의 역참조
	를 출력해보자
	
	*/
	printf("\n\n");
	int num = 84;
	int* p_num = &num;

	printf("변수:%d, 포인터변수:%d, 변수의 주소:%d, 포인터변수의 역참조:%d\n", num, p_num, &num, *p_num);

	*p_num = 8400;

	printf("변수:%d, 포인터변수:%d, 변수의 주소:%d, 포인터변수의 역참조:%d\n", num, p_num, &num, *p_num);

	char c = 'a';
	char* p_c = &c;


	/*포인터 변수를 만들때는
	해당 포인터 변수에 저장할 데이터의 자료형과 
	동일한 포인터형으로	만들어줘야한다.
	이는 포인터의 역참조와 관련되어 있는데
	포인터변수는 주소값이 시작되는 위치만 저장한다.
	하지만 데이터에 따라 차지하는 주소 공간의 크기가 다르기 때문에
	해당 주소값 위치에서 몇개의 데이터를 가지고 올지
	결정하는 것이 포인터변수의 자료형이다.*/

	/*만약, int형 변수의 주소를 char형 포인터에 저장하게 되면
	해당 포인터를 역참조할때
	int형을 4byte의 데이터를 저장하지만
	포인터는 char형, 즉 1byte의 데이터로 판단하기 때문에
	전체 데이터에서 1byte만 가져오게 되고
	이는 정상적인 데이터가 아니게 된다.*/


	//========================================================================================

	/*포인터와 매개변수의 관계*/
	printf("\n\n");
	int p = 10;
	int q = 20;
	printf("p의 주소:%d\n", &p);
	printf("q의 주소:%d\n\n", &q);


	printf("함수 실행 전 p:%d,q:%d\n", p, q);
	swap(p, q);
	printf("함수 실행 후 p:%d,q:%d\n", p, q);




	printf("\n\np의 주소:%d\n", &p);
	printf("q의 주소:%d\n\n", &q);
	printf("함수 실행 전 p:%d,q:%d\n", p, q);
	swap_pointer(&p, &q);
	printf("함수 실행 후 p:%d,q:%d\n", p, q);


	printf("\n\n");
	int s = 10;
	int* p_s = &s;
	scanf(" %d", p_s);
	printf("s:%d", s);

	/*
		s = 10, s는 메모리 99번에 저장되어있음,
		p_s에는 99가 저장되어 있음
		&p_s에 99라는 주소값을 저장한 변수의 주소
	*/



	/*
		매개변수를 3개 입력받고
		첫번째, 두번째 변수값을 더해서
		세번째 변수에 대입해주는 함수를 만들자.
		해당 함수는 반환자가 없으며
		세번째 변수에 대입된 값은
		함수 밖에서도 실제로 적용이 되어 있어야 한다.

		더하기를 할 변수 2개, 결과를 저장할 변수 1개

	*/

	printf("\n\n");
	int x, y, z;
	printf("3가지 숫자를 입력하시오 :");
	scanf(" %d %d %d", &x, &y, &z);
	printf("함수 적용 전 x,y,z 주소값 :%d, %d, %d\n", &x, &y, &z);
	printf("함수 적용 전 x,y,z 값 :%d, %d, %d\n\n", x, y, z);
	add_pointer(&x, &y, &z);
	printf("함수 적용 후 x,y,z 주소값 :%d, %d, %d\n", &x, &y, &z);
	printf("함수 적용 후 x,y,z 값 :%d, %d, %d\n\n", x, y, z);


	/*
		1.실수를 저장하는 변수 A를 만들고
		A의 주소를 저장하는 _A를 만든 뒤
		_A를 이용해서 A의 값을 출력하라.

		2.문자를 저장하는 변수 B를 만들고
		B의 주소를 저장하는 _B를 만든 뒤
		_B를 이용해서 B의 값을 바꾸고
		B를 출력하라.

		3.정수를 저장하는 변수C를 만들고
		C의 주소를 저장하는 _C를 만든 뒤
		_C를 이용해서 변수 C에 데이터를 입력받아서(scanf)
		_C를 이용해 C에 저장된 값을 출력하라.
	*/
	printf("\n\n");
	float A = 15.0f;
	float* _A = &A;
	printf("*_A:%0.1f\n", *_A);

	char B = 'M';
	char* _B = &B;
	*_B = 'J';
	printf("B:%c\n", B);
	printf("B:%c\n",*&B);
	int C = 84;
	int* _C = &C;
	scanf(" %d", _C);
	printf("*_C:%d", *_C);

	//=====================================================================
	//포인터 간의 대입
	printf("\n\n");

	int p1 = 999;
	int q1 = 111;
	int* p2 = &p1;
	int* q2 = &q1;
		
	printf("p1:%d\n", p1);
	printf("q1:%d\n", q1);
	printf("*p2:%d\n", *p2);
	printf("*q2:%d\n", *q2);

	printf("\n\n");

	p2 = q2;
	printf("p1:%d\n", p1);
	printf("q1:%d\n", q1);
	printf("*p2:%d\n", *p2);
	printf("*q2:%d\n", *q2);


	int xi = 100;
	int* xp_i = &i;
	int j = i;
	printf("i:%d\n", i); // 100
	printf("*p_i:%d\n", *p_i);//100
	printf("j:%d\n", j);//100

	i = 200;
	
	printf("i:%d\n", i); // 200
	printf("*p_i:%d\n", *p_i);//200
	printf("j:%d\n", j);//100

	/*포인터와 일반 변수간의 대입의 가장 큰차이는
	변수간의 대입은 현재 시점의 변수의 값을
	복사하기 때문에
	이후에 복사했던 변수밗이 바뀐다고 해서
	복사된 값이 변경되지는 않는다.
	반면에, 포인터변수의 경우
	해당 주소에 저장된 내용물이 아니라
	주소를 복사했기 때문에
	변수의 내용물이 바뀌더라도 주소가 유지되어
	포인터는 변경된 내용물을 실시간으로
	확인할 수 있다.*/

	/*변수간 대입은 사진
	포인터의 대입은 실기간 스트리밍 방송
	방송중인 대상에 변화가 생기면 실시간으로 확인가능
	*/

	//=======================================================================
	printf("\n\n");
	int ii = 10;
	float ff = 3.14;
	char cc = 'C';

	int* pii = &ii;
	float* pff = &ff;
	char* pcc = &cc;

	printf("int형의 크기:%d\n", sizeof(ii));
	printf("float형의 크기:%d\n", sizeof(ff));
	printf("char형의 크기:%d\n", sizeof(cc));

	printf("int*형의 크기:%d\n", sizeof(pii));
	printf("float*형의 크기:%d\n", sizeof(pff));
	printf("char*형의 크기:%d\n", sizeof(pcc));

	/*변수의 크기는 자료형에 따라 차이가 난다.
	int : 4byte, float : 4byte, char : 1byte
	반면에, 포인터 변수는 자료형에 상관없이
	항상 동일한 크기를 가진다.
	int*: 4byte, float*: 4byte, char*: 4byte
	이는 컴퓨터상에서 데이터의 형태에 관계 없이
	저장되는 위치의 주소크기(양식)는 항상 같기 때문이다.*/


	/*그럼에도 불구하고 포인터를 만들때
	저장할 변수의 자료형에 맞춰서 만드는 이유는
	포인터는 데이터가 저장된 위치의 시작점 좌표만 저장하고
	데이터가 어디서 끝나는지는 저장하지 않아서
	포인터를 통해 해당 주소에 저장된 내용물을 가져올때
	몇byte크기의 데이터를 가져와야 할지 알 수가 없다.
	때문에 포인터를 만들때는 몇byte의 자료를 저장한 주소인지
	구분하기 위해서 자료형을 붙여서 만든다.*/

	/*자료형의 크기는 항상 동일하지 않고
	해당 프로그램이 실행되는 환경에 따라 달라질 수 있다.
	32비트 운영체제, 64비트 운영체제
	윈도우, 맥, 리눅스
	사용 프로그램이, 언어의 차이(비주얼스큐디오, devC++, swift, xCode 등)
	환경에 따라서 변수의 크기는 유동적으로 달라질 수 있다.*/

	printf("int형의 크기 :&d\n", sizeof(double));
	//sizeof함수는 변수의 크기를 반환하는 함수이며
	//매개변수로 변수를 직접 넣을 수도 있고
	//자료형을 넣어서 크기를 확인 할 수도 있다.



















	return 0;
}