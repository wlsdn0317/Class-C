#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#include <string.h>
//문자열과 관련된 기능들을 모아둔 코드파일

int main() {
	//배열(array) p.208
	//변수를 생성할때는 한번에 하나씩 생성하고
	//생성된 변수마다 각각 다른 변수명을 만들어줘야하는
	//번거로움이 있다.
	//때문에 동일한 목적을 가진 변수를 다수 만들려 할 경우
	//많은 작업량과 코드가 필요해진다.
	//이러한 문제를 해결하기 위해 나온 방법이
	//배열이라는 개념

	int ary[5];
	//배열생성방법: 자료형 변수명[만들 변수의 갯수]

	ary[0] = 10;
	ary[1] = 20;
	ary[2] = 30;
	ary[3] = 40;
	ary[4] = 50;
	/*생성된 배열 변수는 동일한 이름을 가진 변수이며
	 다만, 서로 다른 '번호(index)'를 가지기 때문에
	 이 번호를 변수명 뒤에 붙여서 변수에 접근한다.
	 */
	 /*※사용하는 번호는 0번부터 시작하며
	 배열의 갯수 -1번까지 사용가능하다.
	 */
	 /*그 외의 부분은 통상적인 변수와 완전히 동일하다.
	 서로 사칙연산이나, 관계연산자를 통한 비교도 가능하며
	 데이터들간의 대입, 다른 코드에 사용하는 것도 가능.*/
	ary[2] = ary[0] + ary[3];
	ary[2] > ary[1];
	printf("%d\n", ary[4]);

	/*배열값의 번호(index)는 무조건 0부터 시작하며
	정수만 사용할 수 있다.
	단, 결과가 정수기만 하면 되기 때문에
	수식을 적는 것은 가능하다.*/

	printf("%d\n", ary[10 % 3]);

	/*10%3은 결과값이 1이기 때문에
	해당 코드는 ary[1]의 데이터를 출력하는 코드.*/

	//배열값의 번호는 정수이기만 하면 되기 때문에
	//정수형 변수인 int값을 배열번호에 넣어서 사용할 수 있다.
	//단, int값이 배열의 범위를 넘어서는 경우에는
	//오류가 발생할 수 있다.

	int x = 4;
	printf("%d\n", ary[x]);

	/*
	float형 변수를 저장하는 10개짜리 배열을 만들고
	임의의 숫자로 배열을 초기화 한 뒤에
	배열 0번부터 9번까지의 데이터를
	출력해보자.*/

	float fary[10];
	fary[0] = 1;
	/*배열에 들어가야하는 데이터가 서로 아무런 연관도
	연속성도 없는 경우에는 위처럼 직접 데이터를 입력한다.*/

	for (int i = 0; i < 10; i++) {
		fary[i] = i + 1.1f;
		printf("%0.1f\n", fary[i]);
	}
	/*반복문을 사용하면 배열 내의 데이터에
	쉽게 접근할 수 있다.*/

	float fary_1[10] = { 9,12,7,55,93,23,19,88,77 };
	/*배열의 선언과 동시에 초기화를 할 수 있다.
	배열의 각 index번째에 넣어둘 데이터를
	중괄호 안에 순서대로 넣어주면 된다.
	이러한 초기화는 배열을 선언(생성)할때만
	사용할 수 있다.*/

	/*초기화에서 빠드린 배열번호의 데이터는
	자동으로 기본값으로 초기화 해준다.
	숫자->0 문자->빈 문자
	중간의 데이터를 빼먹을 수  ex){0, , 32, , 6}(X)
	작성하지 않은 이후의 모든 데이터를 생략 할 수 있다.*/
	printf("\n\n");
	for (int i = 0; i < 10; i++) {
		printf("fary_1[%d]:%0.1f\n", i, fary_1[i]);
	}


	/*printf("\n\n");
	for (int i= 0;i<10;i++)	{
		scanf("%f", &fary_1[i]);
	}
	for (int i = 0; i < 10; i++) {
		printf("fary_1[%d]:%0.1f\n", i, fary_1[i]);
	}*/

	/*배열은 단순히 여러개의 변수를 만드는 것 뿐 아니라
	접근하기 용이한 변수를 만드는 의미이기도 하다.
	scanf, printf가 일반적인 변수 10개에 접근하려 했다면
	scanf, printf를 각각 10줄씩 작성해야겠지만
	배열은 같은 이름의 인덱스 번호만 다른 변수이기 때문에
	반복문을 통해 손쉽게 여러 데이터에 접근할 수 있다.*/

	/*
		정수를 저장하는 10개짜리 배열을 만들고
		임의의 숫자로 초기화 한 뒤에

		사용자에게 숫자를 입력받아서
		해당 숫자가 배열 내에 존재하는지 유무를
		출력해주는 코드를 작성해보자.
	*/
	//printf("\n\n");
	//int y;
	//int i_ary[10] = { 1,2,3,4,5,6,7,8,9,3 };
	//printf("배열내에 숫자가 찾으실 숫자를 입력해주세요 : ");
	//scanf(" %d", &y);
	//for (int i = 0; i < 10; i++) {
	//	if (i_ary[i] == y) {
	//		printf("%d는 i_ary내에 있습니다.\n", y);
	//		break;
	//		//"반복문" 내에 break가 존재한다면
	//		//해당 반복문의 조건에 관계 없이
	//		//break가 실행된 시점에서 반복문을 강제로 종료시킨다.
	//	}
	//	else if (y != i_ary[i] && i == 9) {
	//		printf("%d는 i_ary내에 없습니다.\n", y);
	//		//데이터가 원하는 데이터가 아니고
	//		//배열의 마지막 번째 데이터까지 확인한 경우
	//	}
	//}
	int ii = 0;
	int i2 = 0;
	while (ii < 10) {
		ii++;

		if (ii % 2 == 0) {
			continue;
		}
		i2 += ii;
	}
	/*반복문 내에 continue가 존재하는 경우
	continue 아래에 있는 코드를 실행하지 않고
	다음 반복횟수로 넘어가게 된다.*/

	/*char str[50] = { 'a','b' };
	char str2[50] = "abcde";*/
	//문자열: 문자를 저장하는 변수들을
	//배열로 만들어 문장을 저장하도록 만든 배열을 뜻함.
	//일반 배열처럼 문자 하나하나씩을 중괄호에 넣어서 
	//초기화할 수도 있지만
	//문장을 통째로 큰따옴표를 통해 초기화하는 것도
	//가능하다.

	/*scanf(" %s", &str);
	scanf(" %c", &str2[3]);*/
	//문장을 입력받을때는 %s를 서식문자로 사용하며
	//변수에는 배열명을 그대로 적는다.
	//배열뒤에 인덱스(번호)를 포함하면 문자열이 아닌. 문자 한글자를
	//입력받는 의미이기 때문에 %s가 아닌 %c로 받아야 한다.



	//printf("\n\n문자열 출력\n");
	//printf("%s\n", str2);
	//printf("%c\n", str2[3]);
	//문자열 전체를 출력하고자 한다면
	//%c가 아닌 %s를 사용하며
	//변수부분에는 배열의 이름을 번호 없이
	//그대로 입력한다.
	//배열이름에 번호를 붙이면 문자열 안에 있는
	//문자 '하나'를 의미하기 때문에
	//%s로는 제대로 출력할 수 없다.

	//%s 의 s는 string(문자열)을 뜻한다.

	char _str[5] = "abcd";
	/*문자열은 다른 배열과는 다른 특징이 하나 있는데*/
	printf("\n\n%s\n", _str);

	/*문자열은 배열을 만들때 지정한 갯수보다
	하나 적은 수의 문자를 저장할 수 있다.
	ex) _str은 5개의 문자를 저장하는 문자열이지만
	실제로는 4개의 문자만을 저장할 수 있다.
	5개 저장시에는 출력이 이상하게 된다. */

	/*문자열의 경우 문장의 마지막이 어디인지
	별도로 표시를 해줘야 정상적인 사용이 가능하다.
	따라서 문자열의 저장공간에 적어도 하나의
	여유공간이 있어야 해당 공간에 문장이 여기서
	끝임을 알리는 끝맺음문자(NULL문자)를
	넣을 수 있다.*/
	/*_str[5]를 예시로 들자면
	_str[0] = 'a'
	_str[1] = 'b'
	_str[2]	= 'c'
	_str[3] = 'd'
	_str[4] = '\0'
	위처럼 마지막 배열에는 더 이상 뒤에
	다른 문자가 없음을 나타내는 널문자(\0)가 들어간다.*/

	char myStr[256] = "qwert";
	/*
		myStr[0] = 'q'
		myStr[1] = 'w'
		myStr[2] = 'e'
		myStr[3] = 'r'
		myStr[4] = 't'
		myStr[5] = '\0'
		널문자는 반드시 해당 배열의
		가장 마지막에만 들어가는 건 아니다.
		위처럼 배열크기보다 적은 문장을 입력했을 때는
		배열 중간에도 들어갈 수 있다.
		5번 이후의 배열에는 모두 널문자로 초기화 된다.

		만약 문장 끝에 널문자가 존재하지 않으면
		해당 배열에 저장된 문장이 어디서 끝나는지 모르기때문에
		배열을 출력한다면, 배열의 모든 데이터를 출력하려
		시도할 것이기 때문에 255번까지, 불필요하게 많은 데이터를
		출력하게 된다.
		따라서 이러한 낭비를 막도록 하기위해 문장 끝에는 반드시
		널문자가 들어가야 하며, 이 때문에
		실제 저장 가능한 문자의 갯수는
		저장공간의 갯수 -1개가 된다.
	*/

	char _chr[256] = "zxcvb";
	_chr[6] = 'p';
	//[z][x][c][v][b][\0][p]......
	printf("\n\n%s\n", _chr);

	char _chr2[256] = "qwerasdfzxcv";
	_chr2[5] = '\0';
	printf("\n\n%s", _chr2);



	/*문자열이 초기화 된 후에
	널문자 뒤에 따로 문자를 추가로 넣더라도
	널문자가 존재하는 시점에서
	다른 뒤의 문자는 출력되지 않으며
	반대로 정상적인 문장 중간에
	직접 널문자를 넣으면
	마찬가지로 널문자가 입력된 곳에서
	출력이 졸료된다.*/

	/*char korea[10] = "민진우";
	printf("\n\n%s", korea);
	for (int i = 0; i < 9; i++) {
		printf("\n%c%c", korea[i], korea[i+1]);
	}*/
	/*한글이나 일본어와 같은 특수문자취급을 받는
	문자의 경우, 배열에서 2칸을 차지해서
	하나의 문자를 저장한다.
	때문에 printf로 배열에 저장된 문자 하나를 출력하면
	정상적으로 출력이 되지 않는다.
	이러한 문자는 배열의 크기/2-1개의 문자를 
	저장할 수 있다. (문자의 크기가2, 널문자 공간1개)*/


	/*
		1.본인의 이름을 입력받아서
		이름:입력한이름
		처럼 출력되도록 해보자.

		2.영단어를 입력해서
		반대로 출력되게 해보자. (무조건 5글자를 입력한다는 조건 하에서)
		->printf를 5,4,3,2,1로 출력하는 방식
		->배열에 저장된 문자 자체를 뒤집는 방식
		ex) char c[256]->abcde
		c ->[a][b][c][d][e]->[e][d][c][b][a]

		3.영단어를 입력하고
		해당 단어에 모음이 몇개 들어가는지 출력하자.
		(모음 : a, e, i, o, u)
	*/
	printf("\n\n");
	printf("1번문제\n\n");
	char c_name[256];
	char c_voca[6];
	char c_voca2[50];
	char c_voca3[6];
	printf("이름을 입력해 주세요 : ");
	scanf(" %s", &c_name);
	printf("이름 : %s\n", c_name);

	printf("\n\n");
	printf("2번문제\n\n");
	printf("영단어를 입력해주세요(단,5글자 이하) : ");
	scanf(" %s", &c_voca);

	for (int i = 4; i >= 0; i--) {
		printf("%c", c_voca[i]);
	}
	printf("\n");
	//1.뒤집은 단어를 저장할 배열을 따로 만들기
	for (int j = 0; j < 5; j++) {
		c_voca3[j] = c_voca[4 - j];
	}
	c_voca3[5] = '\0';
	/*글자를 한글자씩 대입했기 때문에
	따로 대입하지 않은 마지막 널문자의 위치에는
	정상적인 글자가 아닌 쓰레기 데이터가 들어가 있다
	따라서 직접 널문자를 따로 넣어주거나
	혹은, 배열을 만들때 빈 문장으로 초기화를 해주면
	배열 전체가 널문자로 초기화 된다.*/
	printf("%s", c_voca3);
	
	printf("\n");
	//2.원본 데이터를 바꾸는 방법
	for (int i = 0; i < 5 / 2 ; i++) {
		//절반이 교체 됐으면 단어 전체가 뒤집어 졌기때문에
		//반복횟수는 문장 길이의 절반만 실행한다.
		int tmp = c_voca[i];
		c_voca[i] = c_voca[4 - i];
		c_voca[4 - i] = tmp;
	}
	printf("str : %s\n",c_voca);


	printf("\n\n");
	printf("3번문제\n\n");
	printf("영단어를 입력해주세요 : ");
	scanf(" %s", &c_voca2);
	int count =0;
	for (int i = 0; i < 50; i++) {
		if (c_voca2[i] == '\0') {
			/*배열의 크기보다 입력된 단어의 길이가 짧다면
			굳이 배열 끝까지 확인할 필요가 없기 때문에
			문장의 끝을 나타내는 널문자가 나온다면
			더 이상 모음을 체크하지 않고
			반복문을 종료시킨다.*/
			break;
		}
		if (c_voca2[i] == 'a' || c_voca2[i] == 'e' || c_voca2[i] == 'i' || c_voca2[i] == 'o' || c_voca2[i] == 'u') {
			count++;
		}
	}
	printf("%s에 들어간 모음 숫자 갯수는 : %d개", c_voca2, count);

	printf("\n\n");
	printf("3번문제에서 입력받은 영단어의 길이는? \n");
	count = 0;
	for (int i = 0; i < 50; i++) {
		if (c_voca2[i] == '\0') {
			count = i;
		}
	}
	printf("영단어의 문자 갯수는 %d개 이다.\n", count);

	/*문자열의 대입 p.224
	문자열은 기본적으로 배열을 생성할때만
	문자열 전체를 한번에 대입 할 수 있으며
	이후에는 한글자씩을 바꾸거나
	scanf을 통해 입력받는 것만 가능하다.
	때문에 외부의 입력이 아닌, 프로그램 내부에서
	문자열을 재차 대입하기 위해서는 별도의 방법이 필요하다.*/
	
	//str = "qwer";(X)
	//위처럼 문자열에 문장을 대입연산자를 통해서 대입할 수 업다.

	strcpy(c_voca, "XYZ"); //c_voca = "XYZ"와 동일한 의미
	strcpy(c_voca2, c_voca);
	//strcpy:string,copy의 약자.

	char str2[5] = "abc";
	char str3[5] = "qwe";
	/*문자열은 생성할 때 대입은 가능하지만
	그 이후에는 변수들끼리라 할지라도 대입이 안된다.*/
	strcpy(str2, str3);
	/*그래서 문자열은 반드시 대입을 하조가 한다면
	strcpy를 사용해야 한다.
	strcpy(대입받을 변수, 대입할 내용(번수))*/

	printf("%s, %s\n", str2, str3);

	//===========================================================
	//다차원배열
	int multiAry[5][5] = { {1,2,3,4,5},{6,7,8,9,10},{11,12,13,14.15},{16,17,18,19,20},{21,22,23,24,25} };
	//5개의 방을가진 5층짜리 건물
	//배열을 중첩해서 배열 안에 배열을 만든다.
	/*배열 안에 배열이 있는 것이기 때문에
	 초기화 할때는 중괄호 안에 중괄호를 넣어서
	 각 배열을 따로 초기화 해준다.
	*/
	/*다차원배열이라는 이름에서 알 수 있다 시피
	2중,3중,4중 몇중으로든 배열을 중첩할 수있지만
	그 구조가 이해하기 난해해지기 때문에
	통상적으로 2차원배열 정도까지를 많이 쓴다.*/
	multiAry[0][3] = 10;
	//일반 배열과 마찬가지로 배열의 index를 넣어서
	//해당 번호에 존재하는 데이터에 접근할 수 있다.



	return 0;
}